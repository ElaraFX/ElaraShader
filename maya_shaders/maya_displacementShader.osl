#ifndef BUILTIN
#define BUILTIN [[ int builtin = 1 ]]
#endif

closure color displacement(point P, normal N) BUILTIN;

/* for mtoer.xml
<maya_displacementShader>
	<maya.name type="STRING">displacementShader</maya.name>
</maya_displacementShader>
*/

shader displacementShader
[[ string help = "Maya displacementShader"]]
(
	float	i_displacement			= 0.0,
	float	i_scale					= 1.0,
	vector	i_vectorDisplacement	= 0.0,
	float	i_vectorEncoding		= 0.0,
	int		i_vectorSpace 			= 1,
	
	output closure color result = 0
)
{
	string space = "world";
	if(i_vectorSpace!=0)
		space = "object";
	if (raytype("displace"))
	{
		if( isconnected(i_vectorDisplacement) == 0 ) //gray-scale displacing
		{
			float magnitude = i_displacement;
			if( i_vectorEncoding == 1 )
				magnitude -= 0.5;
			if( magnitude != 0 ){
				//~ result = displacement(P +magnitude*N, N);
				displace(i_vectorSpace==0?"world":"object", magnitude);
			}
		}
		else //vector displacing
		{
			vector vectorDisplacement = i_vectorDisplacement;
			if(i_vectorEncoding == 1)
				vectorDisplacement -= 0.5;
	
			if ( vectorDisplacement != 0 )
			{
				vector basisx, basisy, basisz;
				if(i_vectorSpace == 0 || i_vectorSpace == 1)
				{
					/* World and object space */
					basisx = vector( 1, 0, 0);
					basisy = vector( 0, 1, 0);
					basisz = vector( 0, 0, 1);
				}
				else
				{
					/* Normalize basis vectors in the specified space */
					basisx = transform( space, dPdu );
					basisy = transform( space, N );
					basisz = transform( space, dPdv );
					
					basisx = normalize( basisx );
					basisy = normalize( basisy );
					basisz = normalize( basisz );
					
				}
				basisx = transform( space, "current", basisx);
				basisy = transform( space, "current", basisy);
				basisz = transform( space, "current", basisz);
				displace(basisx+basisy+basisz);
				
			}
		}
	}
	result = displacement(P,N);
	Ci = result;
}


