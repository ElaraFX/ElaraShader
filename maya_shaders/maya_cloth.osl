// -------------for mtoer.xml------------------------------
// <maya_cloth>
	//~ <maya.name type="STRING">cloth</maya.name>
// </maya_cloth>

#include "mayautil.h"

#define SQR(i) ( (i) * (i) )
#ifndef PI
#define PI 3.1415926536
#endif

shader maya_cloth
[[ string help = "Maya Cloth"]]
(
	// Inputs
	float i_alphaGain =1.0,
	int		i_alphaIsLuminance			= 0,
	float i_alphaOffset = 0.0,
	float i_brightSpread = 0.0,
	color i_colorGain = 1.0,
	color i_colorOffset = 0.0,
	color i_defaultColor = 0.5,
	color i_gapColor = 0.0,
	float i_invert = 0.0,
	float i_randomness = 0.0,
	color i_uColor = 1.0,
	vector i_uvCoord = vector(0.0,0.0,0.0),
	float i_uWave = 0.0,
	float i_uWidth = 0.75,
	color i_vColor = 0.5,
	float i_vWave = 0.0,
	float i_vWidth = 0.75,
	float i_widthSpread = 0.0,
	
	// Outputs
	output float o_outAlpha =1.0,
	output color o_outColor = 1.0
	)
{
	
	float ss = i_uvCoord[0];
	float tt = 1.0-i_uvCoord[1]; // we invert v in place2dTexture, but this makes the checker different with Maya. so we have to invert v back.
	if(ISUVDEFINED(ss, tt))
	{
		/* compute 'ss' and 'tt' filter widths. 
			In ER-OSL implemtation, the dx and dy are the derivates of screen space
			and are always 1 */
		/*uniform*/ float dx = 1.0;
		/*uniform*/ float dy = 1.0;
		float dss = abs(Dx(ss) * dx) + abs(Dy(ss) * dy);
		float dtt = abs(Dx(tt) * dx) + abs(Dy(tt) * dy);
		
		ss = mod(ss, WRAPMAX);
		tt = mod(tt, WRAPMAX);

		if(i_randomness > 0)
		{
			point nn = noise(point(i_uvCoord[0], i_uvCoord[1], 0));

			ss += nn[0] * i_randomness * 2;
			tt += nn[1] * i_randomness * 2;
		}

		float prewaved_ss = ss;
		
		if(i_uWave > 0.0)
		{
			ss -= i_uWave * sin(tt * 2 * PI);
		}

		if(i_vWave > 0.0)
		{
			tt += i_vWave * sin(prewaved_ss * 2 * PI);
		}


		float uWidth = i_uWidth;
		float vWidth = i_vWidth;

		if(i_widthSpread > 0)
		{
			float spread = noise(0.5 * point(i_uvCoord[0], 0.5 * i_uvCoord[1], 1));
			uWidth -= i_widthSpread * spread;

			spread = noise(0.5 * point(0.5 * i_uvCoord[0], i_uvCoord[1], 2));
			vWidth -= i_widthSpread * spread;
		}
		
		ss = mod(ss, 1);
		tt = mod(tt, 1);

		float thread_color = 0; // 1 = uColor; 0 = vColor
		
		// Swap s-t info if we are in the 2nd or 3rd quadrant
		if ((ss >= 0.5 && tt < 0.5) || (ss < 0.5 && tt >= 0.5))
		{
			float tmp = ss;
			ss = tt;
			tt = tmp;
			
			tmp = uWidth;
			uWidth = vWidth;
			vWidth = tmp;
			
			thread_color = 1.0;
		}
		
		ss = mod(2 * ss, 1.0);
		tt = mod(2 * tt, 1.0);
				
		float cloth = 0.0;  // 0 = gap color, 1 = thread color
		float in_gap = 0;   
		
		if (tt < vWidth)
		{
			float cs = ss - 0.5 * uWidth;
			float ct = 2.0 * tt / vWidth - 1.0;
			cloth = 0.75 * (SQR(cs) + SQR(ct));
		}
		else if (ss < uWidth)
		{
			float cs = 2.0 * ss / uWidth - 1.0;
			float ct = tt - 0.5 * vWidth - 1.0;
			cloth = 0.75 * (SQR(cs) + SQR(ct));
			thread_color = 1 - thread_color;
		}
		else
		{
			in_gap = 1.0;
		}
		
		if (in_gap < 1.0)
		{
			cloth = 1.0 - cloth;
			
			if (i_brightSpread > 0)
			{
				float spread = noise(2 * (thread_color ? i_uvCoord[0] : i_uvCoord[1]));
				cloth = mix(cloth, cloth * spread, i_brightSpread);
			}
		}
		
		cloth = clamp(cloth, 0.0, 1.0);
		
		o_outColor = (1 - cloth) * i_gapColor + 
			cloth * (thread_color ? i_uColor : i_vColor);
		
		colorBalance(o_outColor, 
			o_outAlpha,
			1.0,
			i_alphaGain,
			i_alphaOffset,
			i_colorGain,
			i_colorOffset,
			i_invert);
	}
	else
	{
		o_outColor = i_defaultColor;
		o_outAlpha = 1.0;
	}
	o_outAlpha = 1.0;
}



